using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BedrockWorker : SingletonMonoBehaviour
{
	public delegate void GotLeaderboardCallback(uint leaderboardIndex, List<LeaderboardResult> leaderboard);

	public delegate void GotEliteStatusCallback(bool linked);

	public static uint MAX_LEADERBOARD_ROWS = 40u;

	private bool m_GettingLeaderboard;

	private GotLeaderboardCallback m_GettingLeaderboardCallback;

	private GotEliteStatusCallback m_EliteStatusCallback;

	private uint m_GettingLeaderboardIndex;

	private Bedrock.brLeaderboardRow[] m_LastResult = new Bedrock.brLeaderboardRow[MAX_LEADERBOARD_ROWS];

	public Bedrock.brLeaderboardRow[] ResultStore
	{
		get
		{
			return m_LastResult;
		}
		set
		{
			m_LastResult = value;
		}
	}

	public static BedrockWorker Instance
	{
		get
		{
			return SingletonMonoBehaviour.GetAutoGeneratedSingletonInstance<BedrockWorker>();
		}
	}

	protected override void AwakeOnce()
	{
		Object.DontDestroyOnLoad(this);
		Debug.Log("Bedrock Worker Alive");
	}

	public void InvalidateGotleaderboardCallback()
	{
		if (m_GettingLeaderboardCallback != null)
		{
			Debug.Log("Invalidating a leaderboard callback because a leaderboard read task is running");
		}
		m_GettingLeaderboardCallback = null;
	}

	private void ClearLastResults()
	{
		for (int i = 0; i < m_LastResult.Length; i++)
		{
			m_LastResult[i]._userId = 0uL;
		}
	}

	public void InvalidateEliteStatusCallback()
	{
		if (m_EliteStatusCallback != null)
		{
			Debug.Log("Invalidating elite status callback");
		}
		m_EliteStatusCallback = null;
	}

	public IEnumerator UpdateTask(short taskHandle, string name)
	{
		if (taskHandle != -1)
		{
			BedrockTask task = new BedrockTask(taskHandle);
			yield return StartCoroutine(task.WaitForTaskToCompleteOrTimeoutCoroutine());
			Bedrock.brTaskStatus taskStatus;
			if (Bedrock.getTaskStatus(taskHandle, out taskStatus) && taskStatus == Bedrock.brTaskStatus.BR_TASK_SUCCESS)
			{
				Debug.Log(name + " task succeeded.");
				yield break;
			}
			int errorCode = Bedrock.getTaskErrorCode(taskHandle);
			Debug.Log(name + " task failed: " + taskStatus.ToString() + " ErrorCode=" + errorCode);
		}
		else
		{
			Debug.Log("Unable to create task");
		}
	}

	public IEnumerator UpdateWriteTask(short taskHandle, string name)
	{
		yield return StartCoroutine(UpdateTask(taskHandle, name));
		if (taskHandle != -1)
		{
			Bedrock.ReleaseTaskHandle(ref taskHandle);
		}
	}

	public IEnumerator UpdateReadTask(short taskHandle, string name, uint numResults, bool friendsOnly)
	{
		yield return StartCoroutine(UpdateTask(taskHandle, name));
		m_GettingLeaderboard = false;
		if (taskHandle == -1)
		{
			yield break;
		}
		if (m_GettingLeaderboardCallback != null)
		{
			ClearLastResults();
			if (Bedrock.GetLeaderboardResults(taskHandle, m_LastResult, numResults, friendsOnly))
			{
				List<LeaderboardResult> leaderboard = new List<LeaderboardResult>();
				Bedrock.brLeaderboardRow[] lastResult = m_LastResult;
				for (int i = 0; i < lastResult.Length; i++)
				{
					Bedrock.brLeaderboardRow row = lastResult[i];
					if (row.isValid())
					{
						bool elite = ((row._integerFields[0] != 0) ? true : false);
						bool veteran = ((row._integerFields[4] != 0) ? true : false);
						bool isPlayer = row._userId == Bedrock.getDefaultOnlineId();
						int rank = row._integerFields[2];
						int xp = row._integerFields[3];
						int faction = row._integerFields[1] >> 16;
						int wave = row._integerFields[1] & 0xFFFF;
						if (row._integerFields[1] == -1)
						{
							wave = 0;
						}
						leaderboard.Add(new LeaderboardResult(row.getEntityName(), row._userId, row._rating, row._rank, isPlayer, elite, faction, wave, rank, xp, veteran));
					}
				}
				GotLeaderboardCallback callback = m_GettingLeaderboardCallback;
				m_GettingLeaderboardCallback = null;
				callback(m_GettingLeaderboardIndex, leaderboard);
			}
			else
			{
				Debug.Log("GetLeaderboardResults failed");
			}
		}
		Bedrock.ReleaseTaskHandle(ref taskHandle);
	}

	public void WriteMissionLeaderboardValues(List<LeaderboardEntry> entries, bool elite, int rank, int xp)
	{
		Debug.Log("Writing leaderboard values: USER NAME " + Bedrock.getUsername() + " Rank " + rank + " xp " + xp);
		int num = 0;
		if (!Bedrock.isDeviceAnonymouslyLoggedOn())
		{
			Bedrock.brLeaderboardRow[] array = new Bedrock.brLeaderboardRow[entries.Count];
			for (int i = 0; i < entries.Count; i++)
			{
				Debug.Log("Writing to leaderboard " + entries[i].LeaderboardNum + " with rating " + entries[i].Rating);
				array[i]._leaderboardId = entries[i].LeaderboardNum;
				array[i]._userId = Bedrock.getDefaultOnlineId();
				array[i]._writeType = Bedrock.brLeaderboardWriteType.BR_STAT_WRITE_REPLACE;
				array[i]._rating = entries[i].Rating;
				array[i]._floatFields = new float[5];
				array[i]._integerFields = new int[5];
				array[i]._integerFields[0] = (elite ? 1 : 0);
				array[i]._integerFields[1] = (num << 16) + entries[i].Wave;
				array[i]._integerFields[2] = rank;
				array[i]._integerFields[3] = xp;
				array[i]._integerFields[4] = (entries[i].Veteran ? 1 : 0);
				array[i]._floatFields[0] = (array[i]._floatFields[1] = (array[i]._floatFields[2] = (array[i]._floatFields[3] = (array[i]._floatFields[4] = 0f))));
			}
			short taskHandle = Bedrock.StartWriteToLeaderboardRequest(Bedrock.brLobbyServerTier.BR_LOBBY_SERVER_TITLE, array);
			StartCoroutine(UpdateWriteTask(taskHandle, "Write Leaderboard"));
		}
		else
		{
			Debug.Log("Can't write to leaderboard: Activate logged on anonymously");
		}
	}

	public void GetLeaderboardValuesByRank(ulong ulRank, uint leaderBoardIndex, bool friendsOnly, GotLeaderboardCallback callback)
	{
		if (!m_GettingLeaderboard)
		{
			m_GettingLeaderboard = true;
			m_GettingLeaderboardCallback = callback;
			m_GettingLeaderboardIndex = leaderBoardIndex;
			short taskHandle = Bedrock.StartReadLeaderboardByRank(Bedrock.brLobbyServerTier.BR_LOBBY_SERVER_TITLE, leaderBoardIndex, ulRank, MAX_LEADERBOARD_ROWS, friendsOnly, true);
			StartCoroutine(UpdateReadTask(taskHandle, "Read Leaderboard by Rank", MAX_LEADERBOARD_ROWS, friendsOnly));
		}
		else
		{
			Debug.LogError("Attempting to pull leaderboards while already pulling");
		}
	}

	public void GetLeaderboardValuesByRating(ulong ulRating, uint leaderBoardIndex, bool friendsOnly, GotLeaderboardCallback callback)
	{
		if (!m_GettingLeaderboard)
		{
			m_GettingLeaderboard = true;
			m_GettingLeaderboardCallback = callback;
			m_GettingLeaderboardIndex = leaderBoardIndex;
			short taskHandle = Bedrock.StartReadLeaderboardByRating(Bedrock.brLobbyServerTier.BR_LOBBY_SERVER_TITLE, leaderBoardIndex, ulRating, MAX_LEADERBOARD_ROWS, friendsOnly);
			StartCoroutine(UpdateReadTask(taskHandle, "Read Leaderboard by Rating", MAX_LEADERBOARD_ROWS, friendsOnly));
		}
		else
		{
			Debug.LogError("Attempting to pull leaderboards while already pulling");
		}
	}

	public void GetLeaderboardValuesByPivot(uint leaderBoardIndex, bool friendsOnly, GotLeaderboardCallback callback)
	{
		Debug.Log("Reading values for leaderboard " + leaderBoardIndex);
		if (!m_GettingLeaderboard)
		{
			m_GettingLeaderboard = true;
			m_GettingLeaderboardCallback = callback;
			m_GettingLeaderboardIndex = leaderBoardIndex;
			short taskHandle = Bedrock.StartReadLeaderboardByPivot(Bedrock.brLobbyServerTier.BR_LOBBY_SERVER_TITLE, leaderBoardIndex, MAX_LEADERBOARD_ROWS, friendsOnly, true);
			StartCoroutine(UpdateReadTask(taskHandle, "Read Leaderboard by Pivot", MAX_LEADERBOARD_ROWS, friendsOnly));
		}
		else
		{
			Debug.LogError("Attempting to pull leaderboards while already pulling");
		}
	}

	public void GetLeaderboardValuesByGivenPivot(uint leaderBoardIndex, ulong userId, bool friendsOnly, GotLeaderboardCallback callback)
	{
		Debug.Log("Reading values for leaderboard " + leaderBoardIndex);
		if (!m_GettingLeaderboard)
		{
			m_GettingLeaderboard = true;
			m_GettingLeaderboardCallback = callback;
			m_GettingLeaderboardIndex = leaderBoardIndex;
			short taskHandle = Bedrock.StartReadLeaderboardByGivenPivot(Bedrock.brLobbyServerTier.BR_LOBBY_SERVER_TITLE, leaderBoardIndex, userId, MAX_LEADERBOARD_ROWS, friendsOnly);
			StartCoroutine(UpdateReadTask(taskHandle, "Read Leaderboard by Pivot", MAX_LEADERBOARD_ROWS, friendsOnly));
		}
		else
		{
			Debug.LogError("Attempting to pull leaderboards while already pulling");
		}
	}

	public void GetFriendLeaderboardValues(uint leaderBoardIndex, GotLeaderboardCallback callback)
	{
		if (!m_GettingLeaderboard)
		{
			m_GettingLeaderboard = true;
			m_GettingLeaderboardCallback = callback;
			m_GettingLeaderboardIndex = leaderBoardIndex;
			Bedrock.brFriendInfo[] array = new Bedrock.brFriendInfo[100];
			uint numFriends = 0u;
			if (Bedrock.GetFriendsWithCurrentGame(array, ref numFriends))
			{
				ulong[] array2 = new ulong[numFriends + 1];
				for (int i = 0; i < numFriends; i++)
				{
					array2[i] = array[i]._userId;
					Debug.Log("Friend " + i + " " + array[i]._userId);
				}
				ulong defaultOnlineId = Bedrock.getDefaultOnlineId();
				array2[numFriends] = defaultOnlineId;
				short taskHandle = Bedrock.StartReadLeaderboardByUserIds(Bedrock.brLobbyServerTier.BR_LOBBY_SERVER_TITLE, leaderBoardIndex, array2, (uint)array2.Length, true, true);
				StartCoroutine(UpdateReadTask(taskHandle, "Read Leaderboard for friends", (uint)array2.Length, true));
			}
		}
		else
		{
			Debug.LogError("Attempting to pull leaderboards while already pulling");
		}
	}

	public void VerifyEliteStatus(GotEliteStatusCallback callback)
	{
		Debug.Log("Checking Elite status for " + Bedrock.getUsername());
		m_EliteStatusCallback = callback;
		if (!Bedrock.isDeviceAnonymouslyLoggedOn())
		{
			Debug.LogWarning("RKTODO 07/10/14");
		}
		else
		{
			Debug.Log("Can't check elite status: Activate logged on anonymously");
		}
	}

	public IEnumerator UpdateReadEliteStatus(short taskHandle, string name)
	{
		yield return StartCoroutine(UpdateTask(taskHandle, name));
		if (taskHandle != -1)
		{
			Bedrock.brLinkedAccountsInfo accountsInfo;
			if (Bedrock.GetLinkedAccountsResult(taskHandle, out accountsInfo))
			{
				Debug.LogWarning("RKTODO 07/10/14");
			}
			m_EliteStatusCallback = null;
			Bedrock.ReleaseTaskHandle(ref taskHandle);
		}
	}

	public static int FindPlayerInLeaderboard(List<LeaderboardResult> leaderBoard)
	{
		int result = -1;
		for (int i = 0; i < leaderBoard.Count; i++)
		{
			if (leaderBoard[i].IsPlayer)
			{
				result = i;
			}
		}
		return result;
	}
}
