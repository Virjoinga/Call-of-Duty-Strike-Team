using UnityEngine;

public class MissionListings : SingletonMonoBehaviour
{
	public enum eMissionID
	{
		MI_MISSION_01 = 0,
		MI_MISSION_ARCTIC = 1,
		MI_MISSION_AFGHANISTAN = 2,
		MI_MISSION_KOWLOON = 3,
		MI_MISSION_ARCTIC_GMG = 4,
		MI_MISSION_AFGHANISTAN_GMG = 5,
		MI_MISSION_KOWLOON_GMG = 6,
		MI_MISSION_08 = 7,
		MI_MISSION_09 = 8,
		MI_MISSION_10 = 9,
		MI_MISSION_11 = 10,
		MI_MISSION_ART_TEST = 11,
		MI_MISSION_EVERYPLAY = 12,
		MI_MISSION_MOROCCO_GMG = 13,
		MI_MISSION_CARRIER_GMG = 14,
		MI_MISSION_KINVITE = 15,
		MI_MISSION_ARCTIC_FL = 16,
		MI_MISSION_AFGHANISTAN_FL = 17,
		MI_MISSION_KOWLOON_FL = 18,
		MI_MISSION_MOROCCO_FL = 19,
		MI_MISSION_CARRIER_FL = 20,
		MI_MAX = 21
	}

	public class FlashpointData
	{
		public enum Objective
		{
			Survive = 0,
			Clear = 1,
			Collect = 2,
			Destroy = 3,
			Max = 4
		}

		public Objective CurrentObjective = Objective.Max;

		public int TimeLimit = -1;

		public int RequiredKills = -1;

		public int RequiredIntel = -1;

		public int RequiredTargets = -1;

		public int RewardScore;

		public void ResetData()
		{
			CurrentObjective = Objective.Max;
			TimeLimit = -1;
			RequiredKills = -1;
			RequiredIntel = -1;
			RequiredTargets = -1;
		}
	}

	public static eMissionID MI_MISSION_MAX = eMissionID.MI_MAX;

	public static int MAX_SECTIONS_PER_MISSION = 10;

	public MissionData[] Missions;

	public FlashpointData CurrentFlashPointData = new FlashpointData();

	public static MissionListings Instance
	{
		get
		{
			return SingletonMonoBehaviour.GetAutoGeneratedSingletonInstance<MissionListings>();
		}
	}

	protected override void Awake()
	{
		Object.DontDestroyOnLoad(base.gameObject);
		base.Awake();
	}

	public MissionData Mission(eMissionID id)
	{
		MissionData result = null;
		for (int i = 0; i < Missions.Length; i++)
		{
			if (Missions[i] != null && Missions[i].MissionId == id)
			{
				result = Missions[i];
				break;
			}
		}
		return result;
	}

	public void GetNumberOfMissionsForStats(out int StoryMissions, out int SpecOpsOrTutorialMissions)
	{
		StoryMissions = 0;
		SpecOpsOrTutorialMissions = 0;
		for (int i = 0; i < Missions.Length; i++)
		{
			MissionData missionData = Missions[i];
			if (missionData == null || !missionData.IncludeInStats)
			{
				continue;
			}
			for (int j = 0; j < missionData.Sections.Count; j++)
			{
				SectionData sectionData = missionData.Sections[j];
				if (sectionData.IsValidInCurrentBuild)
				{
					if (sectionData.IsSpecOps || sectionData.IsTutorial)
					{
						SpecOpsOrTutorialMissions++;
					}
					else
					{
						StoryMissions++;
					}
				}
			}
		}
	}

	public int GetSpecOpsMissionSection(eMissionID id)
	{
		MissionData missionData = Mission(id);
		if (missionData != null)
		{
			for (int i = 0; i < missionData.Sections.Count; i++)
			{
				if (missionData.Sections[i].IsSpecOps)
				{
					return i;
				}
			}
		}
		return -1;
	}

	public eMissionID FindIDForScene(string sceneName)
	{
		for (int i = 0; i < Missions.Length; i++)
		{
			if (Missions[i] != null && Missions[i].BaseName == sceneName)
			{
				return Missions[i].MissionId;
			}
		}
		return eMissionID.MI_MAX;
	}

	public eMissionID FindIDAndSectionForScene(string sceneName, out int section)
	{
		section = -1;
		for (int i = 0; i < Missions.Length; i++)
		{
			if (Missions[i] == null)
			{
				continue;
			}
			for (int j = 0; j < Missions[i].Sections.Count; j++)
			{
				if (Missions[i].Sections[j].SceneName.StartsWith(sceneName))
				{
					section = j;
					return Missions[i].MissionId;
				}
			}
		}
		return eMissionID.MI_MAX;
	}

	public int FindSectionForScene(eMissionID id, string sceneName)
	{
		MissionData missionData = Mission(id);
		if (missionData != null)
		{
			for (int i = 0; i < missionData.Sections.Count; i++)
			{
				if (missionData.Sections[i].SceneName.StartsWith(sceneName))
				{
					return i;
				}
			}
		}
		return -1;
	}

	public int LeaderboardIDForMissionSection(eMissionID id, int section)
	{
		MissionData missionData = Instance.Mission(id);
		if (missionData != null)
		{
			SectionData sectionData = missionData.Sections[section];
			if (sectionData != null)
			{
				return sectionData.LeaderboardID;
			}
		}
		return -1;
	}

	public static void SetIntelForMissionSection(int sectionId, int amt)
	{
	}

	public void GenerateNewFlashpointMission()
	{
		GenerateNewFlashpointMission(FlashpointData.Objective.Max);
	}

	public void GenerateNewFlashpointMission(FlashpointData.Objective type)
	{
		GMGData instance = GMGData.Instance;
		if (!instance)
		{
			Debug.LogError("Unable to get GMGData Instance!");
		}
		CurrentFlashPointData.ResetData();
		if (type == FlashpointData.Objective.Max)
		{
			int num = Random.Range(0, instance.FPFlavourMaxWeighting);
			int num2 = Random.Range(0, 4);
			while (CurrentFlashPointData.CurrentObjective == FlashpointData.Objective.Max)
			{
				if (instance.FPFlavourWeightings[num2] > num)
				{
					CurrentFlashPointData.CurrentObjective = (FlashpointData.Objective)num2;
					continue;
				}
				num2++;
				if (num2 >= 4)
				{
					num2 = 0;
				}
			}
		}
		else
		{
			CurrentFlashPointData.CurrentObjective = type;
		}
		CurrentFlashPointData.RewardScore = instance.FPBaseRewardScore;
		if (Random.Range(0, instance.FPTimeLimitChance) == 1)
		{
			CurrentFlashPointData.TimeLimit = Random.Range(instance.FPTimeLimitRange[0], instance.FPTimeLimitRange[1]);
			CurrentFlashPointData.RewardScore += instance.FPTimeReward;
		}
		CurrentFlashPointData.RequiredKills = Random.Range(instance.FPRequiredKills[0], instance.FPRequiredKills[1]);
		switch (CurrentFlashPointData.CurrentObjective)
		{
		case FlashpointData.Objective.Survive:
			CurrentFlashPointData.TimeLimit = Random.Range(instance.FPTimeLimitRange_Survive[0], instance.FPTimeLimitRange_Survive[1]);
			break;
		case FlashpointData.Objective.Clear:
			CurrentFlashPointData.TimeLimit = Random.Range(instance.FPTimeLimitRange_Clear[0], instance.FPTimeLimitRange_Clear[1]);
			break;
		case FlashpointData.Objective.Collect:
			CurrentFlashPointData.RequiredIntel = Random.Range(instance.FPRequiredIntel[0], instance.FPRequiredIntel[1]);
			CurrentFlashPointData.TimeLimit = Random.Range(instance.FPTimeLimitRange_Collect[0], instance.FPTimeLimitRange_Collect[1]);
			break;
		case FlashpointData.Objective.Destroy:
			CurrentFlashPointData.RequiredTargets = Random.Range(instance.FPRequiredTargets[0], instance.FPRequiredTargets[1]);
			CurrentFlashPointData.TimeLimit = Random.Range(instance.FPTimeLimitRange_Destroy[0], instance.FPTimeLimitRange_Destroy[1]);
			break;
		}
	}

	public bool FlashpointMissionRunning()
	{
		return CurrentFlashPointData.CurrentObjective != FlashpointData.Objective.Max;
	}
}
