using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ChallengeManager : SingletonMonoBehaviour
{
	private const float ChallengeFinishedRetryTime = 5f;

	private static readonly ILogger _log = LogBuilder.Instance.GetLogger(typeof(ChallengeManager), LogLevel.Debug);

	public static bool UseMockDataProvider = true;

	public static bool UseMockLeaderboardProvider = true;

	public static bool PretendBedrockIsOnlineAllTheTime = true;

	public ChallengeLeaderboardDataCache LeaderboardDataCache;

	public ChallengeInstanceCollection ChallengesUnderway;

	public ChallengeScoreSubmissionManager ScoreSubmissionManager;

	public ChallengeRewardProvider Rewards;

	private ChallengeDataProvider _challengeDataProvider;

	private ChallengeLeaderboardProvider _leaderboardProvider;

	private List<ChallengeMedalEarnedRecord> _medalsEarnedDuringGameplay = new List<ChallengeMedalEarnedRecord>();

	private bool _areChallengesValid;

	private bool _waitingForLoad;

	private uint _lastUpdateTime = uint.MaxValue;

	public static ChallengeManager Instance
	{
		get
		{
			return SingletonMonoBehaviour.GetAutoGeneratedSingletonInstance<ChallengeManager>();
		}
	}

	public bool SuspendUpdateTimer { get; set; }

	public ChallengeDataProvider DataProvider
	{
		get
		{
			return _challengeDataProvider;
		}
	}

	public ChallengeLeaderboardProvider LeaderboardProvider
	{
		get
		{
			return _leaderboardProvider;
		}
	}

	public IEnumerable<ChallengeMedalEarnedRecord> MedalsEarnedDuringLastGameplay
	{
		get
		{
			return _medalsEarnedDuringGameplay;
		}
	}

	public static Bedrock.brUserConnectionStatus ConnectionStatus
	{
		get
		{
			if (PretendBedrockIsOnlineAllTheTime)
			{
				return Bedrock.brUserConnectionStatus.BR_LOGGED_IN_REGISTERED_ONLINE;
			}
			return Bedrock.getUserConnectionStatus();
		}
	}

	public static ulong UserId
	{
		get
		{
			if (PretendBedrockIsOnlineAllTheTime)
			{
				return 1337uL;
			}
			ulong defaultOnlineId = Bedrock.getDefaultOnlineId();
			if (defaultOnlineId == 0L)
			{
				_log.LogError("Invalid USER ID");
			}
			return defaultOnlineId;
		}
	}

	public static string UserName
	{
		get
		{
			if (PretendBedrockIsOnlineAllTheTime)
			{
				return Environment.UserName;
			}
			return Bedrock.getUsername();
		}
	}

	public bool AreChallengesValid
	{
		get
		{
			return _areChallengesValid;
		}
		private set
		{
			if (value != _areChallengesValid)
			{
				_areChallengesValid = value;
				if (!_areChallengesValid)
				{
					OnChallengesInvalidated();
				}
				else
				{
					OnChallengesRevalidated();
				}
			}
		}
	}

	public static event EventHandler<ValueEventArgs<uint>> UpdateComplete;

	public static event EventHandler ChallengesInvalidated;

	public static event EventHandler ChallengesRevalidated;

	protected override void AwakeOnce()
	{
		UseMockDataProvider = Application.isEditor;
		UseMockLeaderboardProvider = Application.isEditor;
		PretendBedrockIsOnlineAllTheTime = Application.isEditor;
		_waitingForLoad = true;
		GameObject gameObject = new GameObject("ChallengeDataProvider");
		gameObject.transform.parent = base.transform;
		if (UseMockDataProvider)
		{
			_log.Log("Using MOCK data provider");
			_challengeDataProvider = gameObject.AddComponent<MockChallengeDataProvider>();
		}
		else
		{
			_log.Log("Using BEDROCK data provider");
			_challengeDataProvider = gameObject.AddComponent<BedrockChallengeDataProvider>();
		}
		GameObject gameObject2 = new GameObject("ChallengeLeaderboardProvider");
		gameObject2.transform.parent = base.transform;
		if (UseMockLeaderboardProvider)
		{
			_log.Log("Using MOCK leaderboard provider");
			_leaderboardProvider = gameObject2.AddComponent<MockChallengeLeaderboardProvider>();
		}
		else
		{
			_log.Log("Using BEDROCK leaderboard provider");
			_leaderboardProvider = gameObject2.AddComponent<BedrockChallengeLeaderboardProvider>();
		}
		_log.Log((!PretendBedrockIsOnlineAllTheTime) ? "Requiring REAL bedrock connection for actions." : "PRETENDING bedrock is connected.");
		if (PretendBedrockIsOnlineAllTheTime)
		{
			_areChallengesValid = true;
		}
		UnityEngine.Object.DontDestroyOnLoad(this);
	}

	private IEnumerator Start()
	{
		yield return StartCoroutine(LoadChallenges());
		StartCoroutine(UpdateTimer());
	}

	public void OnEnable()
	{
		ChallengeData.StatusChanged += HandleChallengeDataStatusChanged;
		Challenge.AttemptCompleting += HandleChallengeAttemptCompleting;
		Challenge.MedalEarned += HandleChallengeMedalEarned;
		Challenge.HighScoreAchieved += HandleChallengeHighScoreAchieved;
		Bedrock.UserResourcesChanged += HandleBedrockUserResourcesChanged;
		ActivateWatcher.ConnectionStatusChange += HandleActivateWatcherConnectionStatusChange;
		SynchronizedClock.ClockSynchronized += HandleClockSynchronized;
		SuspendUpdateTimer = false;
	}

	public void OnDisable()
	{
		ChallengeData.StatusChanged -= HandleChallengeDataStatusChanged;
		Challenge.AttemptCompleting -= HandleChallengeAttemptCompleting;
		Challenge.MedalEarned -= HandleChallengeMedalEarned;
		Bedrock.UserResourcesChanged -= HandleBedrockUserResourcesChanged;
		Challenge.HighScoreAchieved -= HandleChallengeHighScoreAchieved;
		ActivateWatcher.ConnectionStatusChange -= HandleActivateWatcherConnectionStatusChange;
		SynchronizedClock.ClockSynchronized -= HandleClockSynchronized;
		SuspendUpdateTimer = true;
	}

	private void HandleSecureStorageChanged(object sender, EventArgs e)
	{
		bool areChallengesValid = AreChallengesValid;
		AreChallengesValid = false;
		AreChallengesValid = areChallengesValid;
	}

	private void HandleGameManagerGameStarted(object sender, EventArgs e)
	{
		_medalsEarnedDuringGameplay.Clear();
	}

	private void HandleActivateWatcherConnectionStatusChange(object sender, ConnectionStatusChangeEventArgs e)
	{
		AreChallengesValid = IsSupportedStatus(e.NewStatus);
	}

	private bool IsSupportedStatus(Bedrock.brUserConnectionStatus status)
	{
		return status == Bedrock.brUserConnectionStatus.BR_LOGGED_IN_REGISTERED_OFFLINE || status == Bedrock.brUserConnectionStatus.BR_LOGGED_IN_REGISTERED_ONLINE || status == Bedrock.brUserConnectionStatus.BR_LOGGED_IN_ANONYMOUSLY_OFFLINE || status == Bedrock.brUserConnectionStatus.BR_LOGGED_IN_ANONYMOUSLY_ONLINE;
	}

	private void HandleBedrockUserResourcesChanged(object sender, EventArgs e)
	{
		_log.Log("Invalidating DataProvider cache because of SWRVE data change.");
		DataProvider.InvalidateCache();
	}

	private void HandleChallengeDataStatusChanged(object sender, ChallengeData.StatusChangedEventArgs e)
	{
		ChallengeData challengeData = (ChallengeData)sender;
		if (challengeData.Status != ChallengeStatus.Finished || e.OldStatus == ChallengeStatus.Unknown)
		{
			return;
		}
		uint? synchronizedTime = SynchronizedClock.Instance.SynchronizedTime;
		if (synchronizedTime.HasValue && challengeData.DidJoinInCurrentCycle(synchronizedTime.Value))
		{
			if (challengeData.BestScoreSubmittedThisCycle.HasValue)
			{
				DisplayNotification(Language.Get("S_GMG_NOTIFICATION_CLOSED_REWARD"), challengeData);
			}
			else
			{
				DisplayNotification(Language.Get("S_GMG_NOTIFICATION_CLOSED"), challengeData);
			}
		}
	}

	private void HandleChallengeAttemptCompleting(object sender, Challenge.AttemptCompletingEventArgs e)
	{
		Challenge challenge = (Challenge)sender;
		if (!e.TimedOut)
		{
			long leaderboardValue = challenge.LeaderboardValue;
			string formatString = Language.GetFormatString("S_GMG_NOTIFICATION_ATTEMPTCOMPLETED", challenge.ChallengeData.BuildGoalString(leaderboardValue));
			DisplayNotification(formatString, challenge.ChallengeData);
		}
		EventHub.Instance.Report(new Events.ChallengeCompleted());
		ScoreSubmissionManager.SubmitCurrentScoreForChallenge(challenge);
	}

	private void HandleChallengeMedalEarned(object sender, ValueEventArgs<ChallengeMedalType> e)
	{
		Challenge challenge = (Challenge)sender;
		string text = e.Value.ToString().ToUpper();
		string text2 = "[#CBBD34]";
		string text3 = Language.Get("S_CHALLENGE_MEDAL_NOTIFICATION");
		NotificationPanel.Instance.Display(text3 + " " + text2 + text);
		ScoreSubmissionManager.SubmitCurrentScoreForChallenge(challenge);
		if (ActStructure.Instance.MissionInProgress)
		{
			ChallengeMedalEarnedRecord newMedalEarnedRecord = new ChallengeMedalEarnedRecord(challenge.ChallengeData.LocalizedName, challenge.ChallengeData.LocalizedDescription, e.Value);
			RecordMedalAward(newMedalEarnedRecord);
		}
	}

	private void HandleChallengeHighScoreAchieved(object sender, Challenge.BestScoreAchievedEventArgs e)
	{
		Challenge challenge = (Challenge)sender;
		ChallengeData challengeData = challenge.ChallengeData;
		long score = e.Score;
		if (!e.PreviousBest.HasValue)
		{
			_log.Log("Player did not have a previous best for challenge {0} when they logged a new best score ({1}). Not showing High Score dialog.", challengeData.Id, e.Score);
			challengeData.HighScoreShownSinceJoin = true;
		}
		else if (challengeData.LeaderboardType == ChallengeLeaderboardType.MaxOnTop && score == 0L)
		{
			_log.Log("'Best' score of 0 for max-on-top challenge {0} isn't amazing. Don't tell the player about it.", challengeData.Id);
		}
		else if (!challengeData.HighScoreShownSinceJoin)
		{
			string msg = ((!challengeData.IsTime) ? (Language.Get(challenge.ChallengeData.Name) + "\n" + Language.GetFormatString("S_GMG_NOTIFICATION_NEWHIGHSCORE", challenge.ChallengeData.BuildGoalString(score))) : (Language.Get(challenge.ChallengeData.Name) + "\n" + Language.GetFormatString("S_GMG_NOTIFICATION_NEWBESTTIME", TimeUtils.GetLongTimeStringFromSeconds(score))));
			NotificationPanel.Instance.Display(msg);
			challengeData.HighScoreShownSinceJoin = true;
		}
	}

	private void HandleClockSynchronized(object sender, EventArgs args)
	{
		if (_waitingForLoad && AreChallengesValid)
		{
			StartCoroutine(LoadChallenges());
		}
	}

	private void RecordMedalAward(ChallengeMedalEarnedRecord newMedalEarnedRecord)
	{
		_medalsEarnedDuringGameplay.RemoveAll((ChallengeMedalEarnedRecord entry) => entry.Name.Equals(newMedalEarnedRecord.Name));
		_medalsEarnedDuringGameplay.Add(newMedalEarnedRecord);
	}

	private IEnumerator UpdateTimer()
	{
		while (true)
		{
			uint? currentTime = SynchronizedClock.Instance.SynchronizedTime;
			if (currentTime.HasValue && IsSupportedStatus(ConnectionStatus) && _lastUpdateTime != currentTime.Value)
			{
				_lastUpdateTime = currentTime.Value;
				if (!SuspendUpdateTimer)
				{
					foreach (ChallengeData challenge in DataProvider.AllChallenges)
					{
						if (challenge != null)
						{
							challenge.UpdateStatusFromSynchronizedTime(currentTime.Value);
						}
					}
					OnUpdateComplete(currentTime.Value);
				}
			}
			yield return StartCoroutine(CoroutineUtils.WaitForWallTime(0.45f));
		}
	}

	private IEnumerator LoadChallenges()
	{
		Bedrock.brUserConnectionStatus challengeStatus = ConnectionStatus;
		if (!challengeStatus.IsOnline())
		{
			yield break;
		}
		_waitingForLoad = false;
		while (true)
		{
			BedrockTask task = DataProvider.BeginUpdateAllChallenges();
			yield return StartCoroutine(task.WaitForTaskToCompleteOrTimeoutCoroutine());
			if (DataProvider.EndUpdateAllChallenges(task))
			{
				break;
			}
			_log.LogError("Failed to update all tasks. Cannot complete load. Will retry.");
			yield return new WaitForSeconds(1f);
		}
		_log.Log("Updated all tasks. Continuing load.");
		uint? synchronizedTime = SynchronizedClock.Instance.SynchronizedTime;
		if (!synchronizedTime.HasValue)
		{
			_waitingForLoad = true;
			_log.LogWarning("Loading request made while clock was not synchronized. Waiting to retry.");
			yield break;
		}
		foreach (ChallengeData challengeData in DataProvider.AllChallenges)
		{
			if (challengeData != null)
			{
				challengeData.TryLoad(synchronizedTime.Value);
			}
		}
		ScoreSubmissionManager.LoadPendingSubmissions(synchronizedTime.Value);
	}

	private void OnUpdateComplete(uint synchronizedTime)
	{
		if (ChallengeManager.UpdateComplete != null)
		{
			ChallengeManager.UpdateComplete(this, new ValueEventArgs<uint>(synchronizedTime));
		}
	}

	public static void DisplayNotification(string message, ChallengeData challengeData)
	{
		_log.Log("Notification (Challenge " + challengeData.Id + "): " + message);
		NotificationPanel.Instance.Display(Language.Get(challengeData.Name) + "\n" + message);
	}

	private void OnChallengesInvalidated()
	{
		ScoreSubmissionManager.HandleNoLongerInValidActivateState();
		_challengeDataProvider.InvalidateCache();
		_waitingForLoad = true;
		if (ChallengeManager.ChallengesInvalidated != null)
		{
			ChallengeManager.ChallengesInvalidated(this, new EventArgs());
		}
	}

	private void OnChallengesRevalidated()
	{
		StartCoroutine(LoadChallenges());
		if (ChallengeManager.ChallengesRevalidated != null)
		{
			ChallengeManager.ChallengesRevalidated(this, new EventArgs());
		}
	}
}
