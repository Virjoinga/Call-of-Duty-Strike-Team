using System.Collections.Generic;
using UnityEngine;

public class WaveStats : SingletonMonoBehaviour
{
	private List<LeaderboardResult> mCurrentLeaderboardResults;

	private int mCurrentLeaderboardresultsId = -1;

	private int m_Kills;

	private int m_Headshots;

	private int m_ShotsFired;

	private int m_ShotsHit;

	private float m_Time;

	private int m_XPFromKills;

	private int m_XPFromHeadshots;

	private int m_XPOther;

	private int m_AmmoCollected;

	private int m_AmmoBought;

	private int m_MysteryBought;

	private int m_AmmoCacheTimesUsed_Shotgun;

	private int m_AmmoCacheTimesUsed_AssaultRifle;

	private int m_AmmoCacheTimesUsed_LightMachineGun;

	private int m_AmmoCacheTimesUsed_SniperRifle;

	private int m_TimesHealed;

	public int XPForEachWave = 50;

	public static WaveStats Instance
	{
		get
		{
			return SingletonMonoBehaviour.GetAutoGeneratedSingletonInstance<WaveStats>();
		}
	}

	public int Kills
	{
		get
		{
			return m_Kills;
		}
	}

	public int Headshots
	{
		get
		{
			return m_Headshots;
		}
	}

	public float WaveTime
	{
		get
		{
			return m_Time;
		}
	}

	public int XPFromKills
	{
		get
		{
			return m_XPFromKills;
		}
	}

	public int XPFromHeadshots
	{
		get
		{
			return m_XPFromHeadshots;
		}
	}

	public int OtherXP
	{
		get
		{
			return m_XPOther;
		}
	}

	public int AmmoBought
	{
		get
		{
			return m_AmmoBought;
		}
	}

	public int AmmoCollected
	{
		get
		{
			return m_AmmoCollected;
		}
	}

	public int AmmoUsed
	{
		get
		{
			return m_ShotsFired;
		}
	}

	public int MysteryBought
	{
		get
		{
			return m_MysteryBought;
		}
	}

	public int TimesHealed
	{
		get
		{
			return m_TimesHealed;
		}
	}

	public int Accuracy
	{
		get
		{
			if (m_ShotsFired == 0)
			{
				return -1;
			}
			return 100 * m_ShotsHit / m_ShotsFired;
		}
	}

	protected override void Awake()
	{
		Object.DontDestroyOnLoad(this);
		base.Awake();
	}

	public int AmmoCachedTimesUsed(WeaponDescriptor.WeaponClass weaponClass)
	{
		switch (weaponClass)
		{
		case WeaponDescriptor.WeaponClass.Shotgun:
			return m_AmmoCacheTimesUsed_Shotgun;
		case WeaponDescriptor.WeaponClass.AssaultRifle:
			return m_AmmoCacheTimesUsed_AssaultRifle;
		case WeaponDescriptor.WeaponClass.LightMachineGun:
			return m_AmmoCacheTimesUsed_LightMachineGun;
		case WeaponDescriptor.WeaponClass.SniperRifle:
			return m_AmmoCacheTimesUsed_SniperRifle;
		default:
			return 0;
		}
	}

	public int GetNextClosestScoreFriendId(bool ignoreStore)
	{
		if (mCurrentLeaderboardresultsId == -1)
		{
			FetchLeaderboardResults();
		}
		if (mCurrentLeaderboardresultsId >= 0)
		{
			int index = BedrockWorker.FindPlayerInLeaderboard(mCurrentLeaderboardResults);
			for (int i = 0; i < mCurrentLeaderboardResults.Count; i++)
			{
				if (mCurrentLeaderboardResults[i].Rating > 0 && (!ReturnedFriendAlready(i) || ignoreStore) && !mCurrentLeaderboardResults[i].IsPlayer && (mCurrentLeaderboardResults[i].Rating == mCurrentLeaderboardResults[index].Rating || mCurrentLeaderboardResults[index].Rating + 100 >= mCurrentLeaderboardResults[i].Rating))
				{
					if (!ignoreStore)
					{
						GMGData.Instance.FriendIds.Add(i);
					}
					return i;
				}
			}
		}
		return -1;
	}

	public bool WithinRangeOfFriendsScore()
	{
		if (GetNextClosestScoreFriendId(true) == -1)
		{
			return false;
		}
		return true;
	}

	public bool ReturnedFriendAlready(int id)
	{
		for (int i = 0; i < GMGData.Instance.FriendIds.Count; i++)
		{
			if (id == GMGData.Instance.FriendIds[i])
			{
				return true;
			}
		}
		return false;
	}

	public string GetFriendName(int id)
	{
		if (mCurrentLeaderboardresultsId == -1)
		{
			FetchLeaderboardResults();
		}
		if (mCurrentLeaderboardresultsId >= 0)
		{
			return mCurrentLeaderboardResults[id].Name;
		}
		return string.Empty;
	}

	public Texture2D GetFriendAvatar(int id)
	{
		return null;
	}

	protected void Start()
	{
		Reset();
	}

	public void Reset()
	{
		m_Kills = 0;
		m_Headshots = 0;
		m_ShotsFired = 0;
		m_ShotsHit = 0;
		m_Time = 0f;
		m_XPFromKills = 0;
		m_XPFromHeadshots = 0;
		m_XPOther = 0;
		m_AmmoCollected = 0;
		m_AmmoBought = 0;
		m_MysteryBought = 0;
		m_AmmoCacheTimesUsed_Shotgun = 0;
		m_AmmoCacheTimesUsed_AssaultRifle = 0;
		m_AmmoCacheTimesUsed_LightMachineGun = 0;
		m_AmmoCacheTimesUsed_SniperRifle = 0;
		m_TimesHealed = 0;
	}

	private void Update()
	{
		m_Time += Time.deltaTime;
	}

	private void OnEnable()
	{
		if (EventHub.Instance != null)
		{
			EventHub.Instance.OnKill += Kill;
			EventHub.Instance.OnWeaponFired += WeaponFired;
			EventHub.Instance.OnSpecOpsWaveStarted += WaveStarted;
			EventHub.Instance.OnSpecOpsWaveComplete += WaveCompleted;
			EventHub.Instance.OnXPEarned += XPEarned;
			EventHub.Instance.OnAmmoCollected += OnAmmoCollected;
			EventHub.Instance.OnAmmoCacheUsed += OnAmmoBought;
			EventHub.Instance.OnMysteryCacheUsed += OnMysteryBought;
			EventHub.Instance.XPHeliDestroyed += XPHeliDestroyed;
			EventHub.Instance.OnStartMission += OnMissionStarted;
			EventHub.Instance.OnCharacterHealed += OnCharacterHealed;
		}
	}

	private void OnDisable()
	{
		if (EventHub.Instance != null)
		{
			EventHub.Instance.OnKill -= Kill;
			EventHub.Instance.OnWeaponFired -= WeaponFired;
			EventHub.Instance.OnSpecOpsWaveStarted -= WaveStarted;
			EventHub.Instance.OnSpecOpsWaveComplete -= WaveCompleted;
			EventHub.Instance.OnXPEarned -= XPEarned;
			EventHub.Instance.OnAmmoCacheUsed -= OnAmmoBought;
			EventHub.Instance.OnAmmoCollected -= OnAmmoCollected;
			EventHub.Instance.XPHeliDestroyed -= XPHeliDestroyed;
			EventHub.Instance.OnStartMission -= OnMissionStarted;
			EventHub.Instance.OnCharacterHealed -= OnCharacterHealed;
		}
	}

	private void OnMissionStarted(object sender, Events.StartMission args)
	{
		Reset();
	}

	private void OnCharacterHealed(object sender, Events.CharacterHealed args)
	{
		m_TimesHealed++;
	}

	private void OnAmmoBought(object sender, Events.AmmoCacheUsed args)
	{
		m_AmmoBought += args.Amount;
		if (args.WeaponClass == WeaponDescriptor.WeaponClass.Shotgun)
		{
			m_AmmoCacheTimesUsed_Shotgun++;
		}
		if (args.WeaponClass == WeaponDescriptor.WeaponClass.AssaultRifle)
		{
			m_AmmoCacheTimesUsed_AssaultRifle++;
		}
		if (args.WeaponClass == WeaponDescriptor.WeaponClass.LightMachineGun)
		{
			m_AmmoCacheTimesUsed_LightMachineGun++;
		}
		if (args.WeaponClass == WeaponDescriptor.WeaponClass.SniperRifle)
		{
			m_AmmoCacheTimesUsed_SniperRifle++;
		}
	}

	private void OnAmmoCollected(object sender, Events.AmmoCollected args)
	{
		m_AmmoCollected += args.Amount;
	}

	private void OnMysteryBought(object sender, Events.MysteryCacheUsed args)
	{
		m_MysteryBought += args.Amount;
	}

	private void XPHeliDestroyed()
	{
		m_XPFromKills += 300;
	}

	private void Kill(object sender, Events.Kill args)
	{
		if (args.Attacker != null && args.Attacker.PlayerControlled)
		{
			m_Kills++;
			if (args.HeadShot)
			{
				m_Headshots++;
			}
		}
	}

	private void WeaponFired(object sender, Events.WeaponFired args)
	{
		if (args.Attacker.PlayerControlled)
		{
			m_ShotsFired++;
			if (args.HitTarget)
			{
				m_ShotsHit++;
			}
		}
	}

	private void WaveStarted(object sender, Events.SpecOpsWaveStarted args)
	{
		Reset();
		int num = StatsHelper.HighestSpecOpsWaveCompletedGameTotal(ActStructure.Instance.CurrentMissionID, ActStructure.Instance.CurrentMissionSection);
		Debug.Log("Wave Started: " + args.WaveNum + " best so far " + num);
		if (args.WaveNum == num + 1 && args.WaveNum > 1)
		{
			string strMessage = Language.Get("S_SPECOPS_SOCIAL_ON_BEST_WAVE" + Random.Range(1, 3));
			HUDMessenger.Instance.PushMessage(strMessage, false);
			return;
		}
		string empty = string.Empty;
		if (IsWaveSameAsAnyFriend(args.WaveNum, out empty) && args.WaveNum >= num)
		{
			string formatString = Language.GetFormatString("S_SPECOPS_SOCIAL_SAME_WAVE_AS_FRIEND" + Random.Range(1, 3), empty);
			HUDMessenger.Instance.PushMessage(formatString, false);
		}
	}

	private void WaveCompleted(object sender, Events.SpecOpsWaveComplete args)
	{
		int num = StatsHelper.HighestSpecOpsWaveCompletedGameTotal(ActStructure.Instance.CurrentMissionID, ActStructure.Instance.CurrentMissionSection);
		Debug.Log("Wave completed: " + args.WaveNum + " best so far " + num);
		if (args.WaveNum > num)
		{
			string strMessage = Language.Get("S_SPECOPS_SOCIAL_BEST_WAVE" + Random.Range(1, 4));
			HUDMessenger.Instance.PushMessage(strMessage, false);
			return;
		}
		if (args.WaveNum == num - 3)
		{
			string strMessage2 = Language.Get("S_SPECOPS_SOCIAL_3_WAVES_FROM_BEST" + Random.Range(1, 3));
			HUDMessenger.Instance.PushMessage(strMessage2, false);
			return;
		}
		string empty = string.Empty;
		if (IsWaveOneBetterThanAnyFriend(args.WaveNum, out empty) && args.WaveNum > num)
		{
			string formatString = Language.GetFormatString("S_SPECOPS_SOCIAL_BEATEN_FRIEND" + Random.Range(1, 4), empty);
			HUDMessenger.Instance.PushMessage(formatString, false);
		}
	}

	private void XPEarned(object sender, Events.XPEarned args)
	{
		if (args.Type.StartsWith("Kill"))
		{
			m_XPFromKills += args.XP;
		}
		else if (args.Type == "Bonus_Headshot")
		{
			m_XPFromHeadshots += args.XP;
		}
		else
		{
			m_XPOther += args.XP;
		}
	}

	public void FetchLeaderboardResults()
	{
		LeaderboardManager leaderboardManagerInstance = StatsManager.Instance.LeaderboardManagerInstance;
		mCurrentLeaderboardResults = leaderboardManagerInstance.CurrentLeaderboardResults;
		mCurrentLeaderboardresultsId = leaderboardManagerInstance.CurrentLeaderboardResultsId;
		if (mCurrentLeaderboardResults == null)
		{
			Debug.Log("NULL RESULTS FOR LEADERBOARD " + mCurrentLeaderboardresultsId);
			return;
		}
		for (int i = 0; i < mCurrentLeaderboardResults.Count; i++)
		{
			Debug.Log("Leaderboard entry " + i + " = " + mCurrentLeaderboardResults[i].Name + " completed Wave " + mCurrentLeaderboardResults[i].Wave);
		}
	}

	private bool IsWaveSameAsAnyFriend(int waveNum, out string name)
	{
		if (mCurrentLeaderboardresultsId == -1)
		{
			FetchLeaderboardResults();
		}
		if (mCurrentLeaderboardresultsId >= 0)
		{
			for (int i = 0; i < mCurrentLeaderboardResults.Count; i++)
			{
				if (mCurrentLeaderboardResults[i].Wave == waveNum && !mCurrentLeaderboardResults[i].IsPlayer)
				{
					name = mCurrentLeaderboardResults[i].Name;
					return true;
				}
			}
		}
		name = string.Empty;
		return false;
	}

	private bool IsWaveOneBetterThanAnyFriend(int waveNum, out string name)
	{
		if (mCurrentLeaderboardresultsId == -1)
		{
			FetchLeaderboardResults();
		}
		if (mCurrentLeaderboardresultsId >= 0)
		{
			for (int i = 0; i < mCurrentLeaderboardResults.Count; i++)
			{
				if (mCurrentLeaderboardResults[i].Wave > 0 && mCurrentLeaderboardResults[i].Wave + 1 == waveNum && !mCurrentLeaderboardResults[i].IsPlayer)
				{
					name = mCurrentLeaderboardResults[i].Name;
					return true;
				}
			}
		}
		name = string.Empty;
		return false;
	}
}
